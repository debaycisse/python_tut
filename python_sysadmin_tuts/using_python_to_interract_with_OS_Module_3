Script started on 2020-05-29 05:37:41+0100
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep [K[K[K[K[K# we are using gr[K[K;[K'r=[K[Kgrep' along[K[K[K[K[Kto search for every word that contains 'thon' in 
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # /usr/share/wordsdwordsiwordscwordstwords/words[C[C[C[C[C file
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep thon /usr/share/dictwor[K[K[K/words
An[01;31m[Kthon[m[Ky
An[01;31m[Kthon[m[Ky's
Johna[01;31m[Kthon[m[K
Johna[01;31m[Kthon[m[K's
Jona[01;31m[Kthon[m[K
Jona[01;31m[Kthon[m[K's
Mara[01;31m[Kthon[m[K
Mara[01;31m[Kthon[m[K's
Phae[01;31m[Kthon[m[K
Phae[01;31m[Kthon[m[K's
Py[01;31m[Kthon[m[K
Py[01;31m[Kthon[m[K's
diph[01;31m[Kthon[m[Kg
diph[01;31m[Kthon[m[Kg's
diph[01;31m[Kthon[m[Kgs
mara[01;31m[Kthon[m[K
mara[01;31m[Kthon[m[K's
mara[01;31m[Kthon[m[Ker
mara[01;31m[Kthon[m[Ker's
mara[01;31m[Kthon[m[Kers
mara[01;31m[Kthon[m[Ks
py[01;31m[Kthon[m[K
py[01;31m[Kthon[m[K's
py[01;31m[Kthon[m[Ks
tele[01;31m[Kthon[m[K
tele[01;31m[Kthon[m[K's
tele[01;31m[Kthon[m[Ks
[01;31m[Kthon[m[Kg
[01;31m[Kthon[m[Kg's
[01;31m[Kthon[m[Kgs
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # to match our pattern ire[Krespective of the character case, we wil [Kl add -i to the grep, like this [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Ke'll add -i to the grep, like this
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep -i thon [K[K[K[K[Kpython /usr/share/di
dict/                dictionaries-common/ distro-info/         
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep -i python /usr/share/dict/words
[01;31m[KPython[m[K
[01;31m[KPython[m[K's
[01;31m[Kpython[m[K
[01;31m[Kpython[m[K's
[01;31m[Kpython[m[Ks
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # We g[Khave tp know the resweer[K[K[K[Kerved characters that give extra-meaning toi [K[K out search patterns
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # For example - dot marches any character
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # it is a wild [K-card per se
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep[K[K[K[K# let's use it to search fro [K[K[K[K[K[K[K[K[K[K[K[K[K[Kin [K[K[K[K
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep l.rts /use[Kr/share/dict/words  # it[K[Kdot is usedc [K[K to match any words in betweenl and [K[K[K[K[K[K[Kn 'l' and[K[K[K& 'rts'
a[01;31m[Klerts[m[K
b[01;31m[Klurts[m[K
f[01;31m[Klirts[m[K
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # another special character is caret or [K[K[K[K[K[K[K[K[K^ which is called caret or circumflex
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # it[K[K^ indicat[K[K[K[K[K[K[K[K[K[K[K# with dollar sign $...[K[K[K . the caret indic[K[K[K[K[K[K[K[K[K[K[K^ indicates the beginning while $ indicates the end.
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep ^fruit /usr/share/dict/wordsr[K  # it searches for character that starts with 'fruit'
[01;31m[Kfruit[m[K
[01;31m[Kfruit[m[K's
[01;31m[Kfruit[m[Kcake
[01;31m[Kfruit[m[Kcake's
[01;31m[Kfruit[m[Kcakes
[01;31m[Kfruit[m[Ked
[01;31m[Kfruit[m[Kful
[01;31m[Kfruit[m[Kfully
[01;31m[Kfruit[m[Kfulness
[01;31m[Kfruit[m[Kfulness's
[01;31m[Kfruit[m[Kier
[01;31m[Kfruit[m[Kiest
[01;31m[Kfruit[m[King
[01;31m[Kfruit[m[Kion
[01;31m[Kfruit[m[Kion's
[01;31m[Kfruit[m[Kless
[01;31m[Kfruit[m[Klessly
[01;31m[Kfruit[m[Klessness
[01;31m[Kfruit[m[Klessness's
[01;31m[Kfruit[m[Ks
[01;31m[Kfruit[m[Ky
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ grep cat$ /usr/share/dict/words  # to search for character that end with 'cat'
Mus[01;31m[Kcat[m[K
bob[01;31m[Kcat[m[K
[01;31m[Kcat[m[K
copy[01;31m[Kcat[m[K
du[01;31m[Kcat[m[K
lol[01;31m[Kcat[m[K
mus[01;31m[Kcat[m[K
pole[01;31m[Kcat[m[K
pussy[01;31m[Kcat[m[K
s[01;31m[Kcat[m[K
tom[01;31m[Kcat[m[K
wild[01;31m[Kcat[m[K
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # Simple Matching in Python[C[C[C[C[C[C - marching [K[K[K[K[K[K[Ktching of text or string characters
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ # we use re module in python for regular expression
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ pyt[K[K[K# lets [K[K's see how it works in pyt[K[K[K[K[K[K[K[K[K[K[K[K[K's used in python
]0;azeez@azeez-Latitude-E5410: ~/Documents/python_sysadmin_tuts[01;32mazeez@azeez-Latitude-E5410[00m:[01;34m~/Documents/python_sysadmin_tuts[00m$ python3
Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
[GCC 8.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> im[K[K#[Kimport re  # the [K[K[K[Kregular expression module in python is 're'
>>> result = re.search('[Kr''a'z'a'[C, 'plaza')  # we are searching for aza as a pattern in a given string 's[Kplax[K[Kz[K[Kaz[K[Klaza'. the[K[K[KThe 'r' at the beginning of the string indicates  that the string in the[K[K[Kbetween the quotes, is raw-string, wh[K[K[K[K which is what we need to process.
>>> # And the result is stored in 'result' varaiable/[K.
... 
>>> print(result)
<_sre.SRE_Match object; span=(2, 5), match='aza'>
>>> # Rwstring [C[C[C[C[C[C[C[1@a[C[C[C[C[C[C[C[Cmeans that puyth[K[K[K[Kython should not interpret the string but should just pass it as it is to the function that owns the [K[K[K[K[K[K[K[K[K[K[K[K[K[Kin whose bracket the [K[K[K[K[K[Ktrs[K[Ks the r[Kstring is given.
... 
>>> # Always use rawstring for regular expression in python.
... 
>>> # Always use rawstring for regular expression in python.[C[C[C[C[C[CRawstring means that python should not interpret the string but should just pass it as it is to the function in whose brackets the string is given.[C[C[C[Cprint(result)[K[C[C[C[C# And the result is stored in 'result' varaiable.[C[C[C[Cresult = re.search(r'aza', 'plaza')  # we are searching for aza as a pattern in a given string 'plaza'. The 'r' at the beginning of the string indicates tthat the string in between the quotes, is raw-string which is what we need to process.[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[1P[1P[1P[1@b[1@a[C[C[1@a[1@r
>>> print(result)
<_sre.SRE_Match object; span=(1, 4), match='aza'>
>>> # Let's pass s[Ka string that does not match the expression[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
... 
>>> # Let's pass a string that does not match the expression[C[C[C[Cprint(result)[K[C[C[C[Cresult = re.search(r'aza', 'bazaar')  [1P[1P[1P[1P[1P[1P[1@m[1@a[1@z[1@e[C[C[C[C
>>> print(result)
None
>>> # let's str[K[K[Ktry with some of the special characters
... print()r)e).)s)e)arch()[C)[C'))^))X))[1P))x))')),)) ))'))x))e))n))o))n))o))[1P))'))[C[C  # this means that it should search any character that begins with 'x'
<_sre.SRE_Match object; span=(0, 1), match='x'>
>>> 
>>> # What about if we use dot
... 
>>> print()r)e).)s)e)a)rch()[C)r))'))p)).))n))g))')),)) ))'))p))e))n))g))u))i))n))'))[C[C
<_sre.SRE_Match object; span=(0, 4), match='peng'>
>>> # dot is used to represent any character - that is a single character for a single dot
... 
>>> # dot is used to represent any character - that is a single character for a single dot[C[C[C[C[50Pprint(re.search(r'p.ng', 'penguin'))[C[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))c'))l'))a'))p'))p'))i'))n'))g'))[C[C[C
<_sre.SRE_Match object; span=(4, 8), match='ping'>
>>> print(re.search(r'p.ng', 'clapping'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))s'))p'))o'))n'))g'))e'))[C[C[C
<_sre.SRE_Match object; span=(1, 5), match='pong'>
>>> 
>>> # to match our pattern in CASE-INSENSITIVE M[Kmode or manner, we will add re.IGNORECASE option to our regular expression syntax
... # to match our pattern in CASE-INSENSITIVE mode or manner, we will add re.IGNORECASE option to our regular expression syntax[C[C[C[Cprint(re.search(r'p.ng', 'sponge'))[K[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))clapping'))[K[C[C)[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))P'))a'))n'))g'))e'))a'))[C[C,)) ))r))e)).))I))G))N))ORECASE))[C[C
<_sre.SRE_Match object; span=(0, 4), match='Pang'>
>>> 
>>> 
>>> 
>>> 
>>> # Wild [K-card and character classes
... 
>>> # Wo[Kildcard is used to match any character but what about if we wi[Kant to restrict our pattern to a particular [K[K[K[K[K[K[K[K[K[K[Kspecific character, that is h[Kwhen we use character classe ss...th[K[K[K[K[K[K...they are written in between brackets - () and the given pattern insideth [K[K[K the bracket will [K[K[K[K[K[K, is what the regex will look up for in a f[Kg[K[K given data or file.
... For example, let's mact[K[Ktch pattern that allow both upper an[K[K[Kcase and lowercase 'p'
  File "<stdin>", line 2
    For example, let's match pattern that allow both uppercase and lowercase 'p'
              ^
SyntaxError: invalid syntax
>>> For example, let's match pattern that allow both uppercase and lowercase 'p'[C[C[C[C# Wildcard is used to match any character but what about if we want to restrict our pattern to a specific character, that is when we use character classess...they are written in between brackets - () and the given pattern inside the bracket, is what the regex will look up for in a given data or file.
... # Wildcard is used to match any character but what about if we want to restrict our pattern to a specific character, that is when we use character classess...they are written in between brackets - () and the given pattern inside the bracket, is what the regex will look up for in a given data or file.[A[C[C[C[C[K
[K[A[C[C[C[C# For exmaple [K, let's assume we want to match a pattern that allow nb[K[Kboth uppcas[K[K[Kercase & lowersace [K[K[K[K[Kcase 'p'
... 
>>> print()r)e).)s)e)a)rch()()[C)r))'))[))P))p))]))y))t))h))o))n))')),)) ))'))P))y))t))h))o))n))'))[C[C  # POM[KINT OF CORRECTION :- not[K[K[Kour pattern is housed inside square backet[K[K[K[K[K[K[Kd brackets [] and not 90[K[K()
... 
... 
... )
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: search() missing 1 required positional argument: 'string'
>>> )print(re.search((r'[Pp]ython', 'Python'))  # POINT OF CORRECTION :- our pattern is housed inside squared brackets [] and not ()[C[C[C[C[C[C[1P[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='Python'>
>>> # we can use lowercase a to lo[K[K[K[K[K[K[K'a' to lowercase 'z' to macth [K[K[K[Ktch any character from 'a' to 'z'...let's see o[Kit in an example
... print()r)e).)s)e)arch()[C)'))[1P))r))'))[))a))-))z))]))')),)) ))'))'))T'))h'))e')) '))e'))n'))d')) '))o'))f')) '))t'))h'))e')) '))h'))i'))g'))h'))w'))a'))y'))[C[C[C
<_sre.SRE_Match object; span=(1, 2), match='h'>
>>> print(re.search(r'[a-z]', 'The end of the highway'))[1@w[1@a[1@y[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(18, 22), match='hway'>
>>> ptiny[K[K[K[Krint(r'','')[C[1P,'')[1P,'')[1P,'')r,'')e,'').,'')s,'')e,'')a,'')rch(,'')),'')[1P,'')[C[C)')[1P')[C[C)',''))',''))[Cr'',''))[C[',''))]',''))a]',''))-]',''))z]',''))[Cw',''))a',''))y',''))[C[C[CW'))h'))a'))t')) '))a')) '))w'))a'))y')) '))t')) '))[1P'))o')) '))g'))o'))[C[C[C
None
>>> N[K'none' is re[K[Kprinted because there is space before 'way' and space in[Ks not a character in a-z''a-z'[C[C[C[C
  File "<stdin>", line 1
    'none' is printed because there is space before 'way' and space is not a character in 'a-z'
                            ^
SyntaxError: invalid syntax
>>> 'none' is printed because there is space before 'way' and space is not a character in 'a-z'[C[C[C[C[1@#[1@ [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
... # uppercase 'A-z[KZ' can also be used as the loc[K[K[K[K[K[K[K[Kw[K[Ks well.
... 
>>> # '0-9' can also be matched as well for numbers
... 
>>> # We can o[Kcombine as many ranges and symbols as we want, like this
... pr[K[K
>>> print()r)e).)s)e)a)rch()[C)'))c))l))o))u))d))[))]))a]))-]))z]))A]))-]))Z]))0]))-]))9]))[C')),)) ))'))c))l))o))u))d))y))'))[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloudy'>
>>> print(re.search('cloud[a-zA-Z0-9]', 'cloudy'))9'))[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloudy'>
>>> print(re.search('cloud[a-zA-Z0-9]', 'cloudy9'))9'))9'))[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloudy'>
>>> print(re.search('cloud[a-zA-Z0-9]', 'cloudy999'))[2P'))[1P'))9'))[1P))"))[1Pcloudy9"))"cloudy9"))[C[C[1P[1@"[1P[1@"[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloudy'>
>>> print(re.search("cloud[a-zA-Z0-9]", "cloudy9"))[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C'cloud[a-zA-Z0-9]', 'cloudy999'))[1P[1P[1P[1P[1P[1P[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
None
>>> print(re.search('cloud[0-9]', 'cloudy999'))[1@y[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 7), match='cloudy9'>
>>> print(re.search('cloudy[0-9]', 'cloudy999'))[1P[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C"cloud[a-zA-Z0-9]", "cloudy9"))[C[C[C[C[C[C[CScript started on 2020-05-29 11:46:32+0100
]0;azeez@azeez-Inspiron-15-3567: ~/Documents[01;32mazeez@azeez-Inspiron-15-3567[00m:[01;34m~/Documents[00m$ python3
Python 3.6.9 (default, Apr 18 2020, 01:56:04) 
[GCC 8.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> # Simple Matching in python
... 
>>> print[K[K[K[K[Kresult = re[K[K[K[K[K[K[K[K[K[K[Kimport re
>>> result = re.search()r)@)@)[1P)[1P)")")[1P)a)z)e)[1P)a)"),) )")p)l)a)z)a)")[C
>>> print(result)
<_sre.SRE_Match object; span=(2, 5), match='aza'>
>>> print(result)[C[C[C[Cresult = re.search(r"aza", "plaza")[1Pa")[1P")[1Pa")[1Pa")[1P")b")a")z")a")a")r")[C[C
>>> result = re.search(r"aza", "bazaar")[C[C[C[C[23Pprint(result)
<_sre.SRE_Match object; span=(1, 4), match='aza'>
>>> print(result)[C[C[C[Cresult = re.search(r"aza", "bazaar")[1P")[1P")[1P")[1P")[1P")[1P")m")a")z")e")[C[C
>>> result = re.search(r"aza", "maze")[C[C[C[C[21Pprint(result)
None
>>> @[K~ [K[K# since there is no matching worl[Kd in the given text
... 
>>> print(re.search(r"x", "xenon"))[1@^[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 1), match='x'>
>>> print(re.search(r"^x", "xenon"))[1P"))[1P"))[1P"))[1P"))[1P"))p"))e"))n"))g"))u"))i"))n"))[1P[1P[1@p[1@.[1@n[1@g[C[C[C[C[C[C[C[C[C[C[C[C[C[C  # dot i s[K[Ks used to match any single char acet[K[Kter
<_sre.SRE_Match object; span=(0, 4), match='peng'>
>>> print(re.search(r"p.ng", "penguin"))  # dot is used to match any single charaacter[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C^x", "xenon"))[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C# since there is no matching word in the given text[C[C[C[C[19Pprint(re.search(r"^x", "xenon"))p.ng", "penguin"))  # dot is used to match any single charaacter[K[K[K[K[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[1P[1P[1P[1P[1P[1P[1@c[1@l[1@a[1@p[1@p[1P[1P[1P[1P[1P[1P[1@c[1@l[1@a[1@p[1@p[1@i[1@n[1@g
<_sre.SRE_Match object; span=(4, 8), match='ping'>
>>> print(re.search(r"p.ng", "clapping")) [1P[1P[1P[1P[1P[1P[1P[1P[1@s[1@p[1@o[1@n[1@g[1@e[C[C[C[C
<_sre.SRE_Match object; span=(1, 5), match='pong'>
>>> print(re.search(r"p.ng", "sponge")) [2@clapping[C[C[C[C[2Psponge[C[C[C[C[1@,[1@ [1@r[1@e[1@.[1@I[1@G[1@N[7@ORECASE[C[C[C[C[C[C[C[C[C[1P[1P[1P[1P[1P[1P[1@P[1@a[1@n[1@g[1@e[1@a[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 4), match='Pang'>
>>> print()r)e).)s)e)a)rch()[C)r))@))[1P))"))[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K
>>> # to seac[Krch a [K[K[K[K[K[K[K[K[K[K[K[K[K[KTo restrict our search pattern to a group of characters - more than a single  character, we will use ch[K[K'character class'...[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C#To restrict our search pattern to a group of characters - more than a single[1@ [A[C[C[C To restrict our search pattern to a group of characters - more than a singl[1@e[A[C[C[C[C
[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
... ~ [K[K# character classes are written in between squared bracket and[K[K[K[K
... 
>>> ~ [K[K# For exampe[K[K[K[K[K[K[K[K[K[KExampel[K[Kles : To search for n[Kbop[K[K[K[K both [K[K[K[K[K'p' as a pette[K[K[K[Kattren and allow the pattern to accept  both lower and uppercase...our code will look like the below.
... print()r)e).)s)e)a)rch()[C)r))"))[))]))p]))P]))[Cy))t))h))o))n))[C")),)) ))"))P))y))t))h))o))n))"))[C[C)[C[K[C[C
<_sre.SRE_Match object; span=(0, 6), match='Python'>
>>> 
>>> # Any charcte[K[K[Kacter from[K[K[K[Kbetween a to z[K[K[K[K[K[K'a' to 'z' can also be searched, like this 
... print()r)e).)s)e)arch()[C)r))'))[1P))'))[))a))-))z))]))')),)) ))'))'))[1@w[1@a[1@y[C[C[C[CT'))h'))e')) '))e'))n'))d')) '))o'))f')) '))t'))h'))e')) '))h'))i'))g'))h')) '))w'))a'))y'))[C[C[C
None
>>> print(re.search(r'[a-z]way', 'The end of the high way'))[1Pway'))[C[C[C[C[C[C
<_sre.SRE_Match object; span=(18, 22), match='hway'>
>>> print(re.search(r'[a-z]way', 'The end of the highway'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))W'))h'))a'))t')) '))a')) '))w'))a'))y')) '))t'))o')) '))g'))o'))[C[C[C
None
>>> '[K# we go because there is space before the word #[K'way'
... 
>>> print()r)e).)s)e)a)r)ch()[C)r))"))"))["))]"))a]"))-]"))z]"))A]"))-]"))Z]"))0]"))-]"))9]"))c[a-zA-Z0-9]"))l[a-zA-Z0-9]"))o[a-zA-Z0-9]"))u[a-zA-Z0-9]"))d[a-zA-Z0-9]"))[C[C[C[C[C[C[C[C[C[C[C[C,)) ))"))c))l))o))u))d))y))"))[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloudy'>
>>> 
>>> 
>>> print(re.search(r"cloud[a-zA-Z0-9]", "cloudy"))[1P"))9"))[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='cloud9'>
>>> 
>>> 
>>> 
>>> # To search for a pattern i[Ktaht is [K[K[K[K[K[K[Khat is no [Kt in a group, we will use caret in [Kside a  character class' squared bracket - [^] .... lis[Kke the below
... 
>>> print()r)e).)s)e)r)[1P)a)rch()[C)r))@))[1P))"))"))["))^"))a"))-"))z"))A"))-"))Z"))]"))[C,)) ))"))"))T"))h"))e")) "))[1P"))[1P"))i"))s")) "))i"))s")) "))a")) "))s"))e"))n"))t"))e"))n"))c"))e")) "))w"))i"))h"))t"))[1P"))[1P"))t"))h")) "))s"))p"))a"))c"))e"))s"))."))[C[C[C  ~ [K[K# ths[Kisi s  [K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K is  going to match a sentence[K[K[K[K[K[K[K[K[K[Kany other charat[Kcter than a[K'aa[K' to 'z' or 'A' to 'Z'
<_sre.SRE_Match object; span=(4, 5), match=' '>
>>> # as shown it matched only the first sop[K[Kpace.
... 
>>> 
>>> 
>>> # as shown it matched only the first space.[C[C[C[Cprint(re.search(r"[^a-zA-Z]", "This is a sentence with spaces."))  # this is  going to match any other character than 'a' to 'z' or 'A' to 'Z'[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[C[C[C[C[1@ [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C  # Since  we have jus t[K[Ks[Kt added space character in our pattern, it means that space w[Kcharacter  will be among the character that will not be matched...see the below matched ch aracter for confirmation.
<_sre.SRE_Match object; span=(30, 31), match='.'>
>>> @[K@[K~ [K# yes[K[K[K[K[K[K# yes, it matched '.' which is the only character that is not specified in o ur pattern - character class
... 
>>> 
>>> 
>>> 
>>> 
>>> 
>>> 
>>> 
>>> DD[K[K# tO SEARCH [K[K[K[K[K[K[K[K[K[KTo search for either a char[K[K[K[Kpattern or the [K[K[K[Kanother, we use pipe - | 
... pri[K[K[K
>>> print()r)e).)s)e)arch()[C)r))'))'))c'))a'))t'))|'))d'))g'))[1P'))o'))g'))[C,)) ))'))H))e)) ))l))i))k))e))s)) ))c))a))t))s)).))'))[C[C
<_sre.SRE_Match object; span=(9, 12), match='cat'>
>>> # it matched cats[Ks[K...;[Klet's check another exampe using dog[Kg
... 
>>> # it matched cat...let's check another exampe using dog[C[C[C[C[9Pprint(re.search(r'cat|dog', 'He likes cats.'))[1Ps.'))[1Ps.'))[1Ps.'))[1Ps.'))[1P.'))[1Ps.'))[1Ps.'))[1Ps.'))[1Ps.'))ds.'))os.'))ns.'))[1Ps.'))es.'))[Cs.'))ts.')) s.'))ns.'))os.'))ts.'))[1Ps.'))[1Ps.'))[1Ps.'))[1Ps.'))[1Ps.')) s.'))ns.'))os.'))ts.')) s.'))ls.'))is.'))ks.'))es.')) s.'))ds.'))os.'))gs.'))[C[C[C[C[C
<_sre.SRE_Match object; span=(17, 20), match='dog'>
>>> # yes, this time arround, it matched dog
... 
>>>     k[K[Kkk[K[Klet's[K[K[K[K[K# Let's try with a [Km[Kn expression that contains both cat and dog
... 
>>> # Let's try with an expression that contains both cat and dog[C[C[C[C[C[C[21Pyes, this time arround, it matche[C[C[C[C[C[C[C[C[Cprint(re.search(r'cat|dog', 'He does not like dogs.')) .'))a.'))n.'))d.')) .'))c.'))a.'))t.'))s.'))[C[C[C[C
<_sre.SRE_Match object; span=(17, 20), match='dog'>
>>>  ~ [K[K[K# it matched only the first found pattern
... 
>>> ~[K# top find [K[K[K[K[K[K[K find all posi[Ksible ot[Kutcome [Ks oh[Kther than the first-to-be-found, we will us e another function of re module, called 'findall'
... 
>>> print()r)e).)f)i)n)d)a)ll()[C)r))e))[1P))[1P))r))'))c))a))t))s))|))d))o))g))s))]))[cats|dogs]))[C[C[C[C[C[C[C[C[C[C')),)) ))'))H))e)) ))d))o))e))s)) ))n))o))t)) ))l))i))k))e)) ))b))o))t))h)) ))c))a))t))s)) ))a))n))d)) ))d))o))g))s))'))[C[C
['d', 'o', 's', 'o', 't', 'o', 't', 'c', 'a', 't', 's', 'a', 'd', 'd', 'o', 'g', 's']
>>> print(re.findall(r'[cats|dogs]', 'He does not like both cats and dogs'))[1P[1P[C[C[C[1P[C[C[C[1P[1P[1@g[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
['cat', 'dog']
>>> 
>>> 
>>> ~ [K[K# What do you think that we will need op[K[Kto do, if we want top [K[K march ma[Kore than o nce
... 
>>> 
>>> 
>>> 
>>> # Repetition Qualifies[Krs
... 
>>> ff[K[K# That is a way to match pattern as many times as possible or as the phrase  implies r[K'repeatedly'
... 
>>> # .*u.*s.*i.*n.* .*[1P.*g.* .*[C[C[C[C - dot and star, will match any character but as many timer[Ks as pos sible
... 
>>> print(re.search('Py*[K.*n'[C[C[C[C[C[C[C[Cr'Py.*n'[C[C[C[C[C[C[C, [1@p[1@[[C[C[1@][C[C[C[C[C[C[C ' P y g m a l i o n ' ) ) 
<_sre.SRE_Match object; span=(0, 9), match='Pygmalion'>
>>> print(re.search(r'[pP]y.*n', 'Pygmalion')) [1P[1P[1P[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1@,[1@ [1@r[1@e[1@.[1@I[1@G[8@NORECASE[C[C[C
<_sre.SRE_Match object; span=(0, 9), match='Pygmalion'>
>>> 
>>> print(re.search(r'py.*n', 'Pygmalion', re.IGNORECASE)) [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[12P[pP]y.*n', 'Pygmalion'[C[C[C[C[C[C[C# using .* - dot and star, will match any character but as many times as posssible[A[33Pprint(re.search(r'[pP]y.*n', 'Pygmalion')) 
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P[1P[1P[1P[1@P[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P[1P[1P[1P[1P[1P[1P[1@t[1@h[1@o[1@n[1@ [1@P[1@r[1@o[1@g[1@r[1@a[1@m[1@m[1@i[1@n[1@g[C[C[C[C
<_sre.SRE_Match object; span=(0, 17), match='Python Programmin'>
>>> 
>>> 
>>> ~[K# Matching as many time [Ks to [K[K[K[K, is called 'greedy#[K' in por[K[Krogramming tern[Km...though it  is ma=[K[Kodifiedable [K[K[K[K[K-able
... 
>>> 
>>> 
>>> ~ [K#[K[K# if we want the p[Kpattern to matc [Kh only th[K[Kcharacter [K- [K[K - withouut[K[Kt s[Ke[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Ktext character, excluding the exclama tion characters [K, like space, comma and so on...we will need to use the ch[K[K[K[K[K[K[K[K[K[Kspecify the range r [K[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ce  of our character instead of using dot.
... 
>>> 
>>> # if we want the pattern to match only text character, excluding the exclamattion characters, like space, comma and so on...we will need to specify the range  of our character instead of using dot.[A[A[C[C[C[C[C[CMatching as many times, is called 'greedy' in programming term...though it [Cs modified-able[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[A[C[C[C[C[27Pprint(re.search(r'Py.*n', 'Python Programming')) 
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P[1@[[1@][1@a[1@-[1@z[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
<_sre.SRE_Match object; span=(0, 6), match='Python'>
>>> 
>>> 
>>> print(re.search(r'Py[a-z]*n', 'Python Programming')) [C[C[C[C# if we want the pattern to match only text character, excluding the exclamattion characters, like space, comma and so on...we will need to specify the range  of our character instead of using dot.[A[A[C[C[C[C[C[CMatching as many times, is called 'greedy' in programming term...though it [Cs modified-able[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[A[C[C[C[C[27Pprint(re.search(r'Py.*n', 'Python Programming')) 
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[C[C[C[C[1P[1P[1@*[1@[[1@][1@a[1@-[1@z[C[C[C[C[C[C[C[C[C[C[C[C[C[C [C ~ [1P 
<_sre.SRE_Match object; span=(0, 3), match='Pyn'>
>>> # It matched the word, because zeo[Kro match of the given pattern in between th e op[Kther given pattern is la[K[Kalso possible and allowex[Kd
... 
>>> 
>>> 
>>> +? [1@#[1@ [C[C[Ccan be used to construct more complex pattern matching
... # + - is used to match occurence of a [C[C[C[C[C[C[1@ [1@o[1@n[1@e[C[1@ [1@o[1@r[C[1@ [1@m[1@o[1@r[1@e[C[C[C[C[C[C[C[C[C[C[1@s[C[C[C[C[C[C[K[Ka gi[K[Kpattern that is given bef ore it -[K[K, like o+ - this means more[K[K[K[Kone or more occurences of t[Kletter 'o'
... 
>>> print(re.search(r"o=[K+l+@[K", '[K"goldfish"))  # ths [K[Kis should match mo[K[Kone or more opc[K[Kccur n[Kences of the [K[K[K[Kboth 'o' and 'l'
<_sre.SRE_Match object; span=(1, 3), match='ol'>
>>> # there is only one occurence of both as ho[K[Kshow[K[K[K[K[K[K[K[K[K[K[K[K'ol'[K[K[K[K'o' and 'l' , [K[K[K, that is 'ol'
... 
>>> # there is only one occurence of 'o' and 'l', that is 'ol'[C[C[C[Cprint(re.search(r"o+l+", "goldfish"))  # this should match one or more occureences of both 'o' and 'l'[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[1P[1P[1P[1P[1P[1P[1P[1P[1@w[1@o[1@o[1@l[1@y[1P[1@l[1@y[C[C[C[C
<_sre.SRE_Match object; span=(1, 5), match='ooll'>
>>> 
>>> 
>>> # Let's try some [Kthin [Kg that doen[Ks not match
... # Let's try something that does not match[C[C[C[C[5Pprint(re.search(r"o+l+", "woolly")) [1P[1P[1P[1P[1P[1P[1@b[1@o[1@i[1@l[C[C[C[C
None
>>> # Since 'o' and 'l' never followed themselves or coma [K[Ke after one another in t he search data
... 
>>> #[K
>>> 
>>> 
>>> # ? - thu=[K[Ks [K[Kis is usd [K[Ked y=[Kt[K[Kto match 0 or 1 occurence of a given pattern before it.
... ~[K# Let's see th[Kit [K[K[K[Kit in anexam[K[K[K[K exampe[Kle below.
... 
>>> print(re.search(r'r[Kp>[K?each', 'To each their own'))
<_sre.SRE_Match object; span=(3, 7), match='each'>
>>> ~[K# Since the [K[K[K[K'p' which is among the given pattern i[K[K, is not present [K, then it is igo [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[K
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cn ored r [K[Kor makr[K[Kt[Krked as optional;[K.
... # L:[Ket's see another example in which 'p' is present
... 
>>> # Let's see another example in which 'p' is present[C[C[C[C[C[CSince 'p' which is among the given pattern, is not present, then it is ignoored or marked as optional.[A[C[C[C[C[28Pprint(re.search(r'p?each', 'To each their own'))
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))[1P'))I')) '))l'))i'))k'))e')) '))p'))e'))a'))c'))h'))e'))s'))[C[C[C
<_sre.SRE_Match object; span=(7, 12), match='peach'>
>>> print(re.search(r'p?each', 'I like peaches')) '))t'))e'))a'))[1P'))[1P'))e'))r'))e'))a'))c'))h'))e'))s')),'))[1P')) '))a'))n'))d')) '))t'))r'))e'))c'))h'))[1P'))[1P'))c'))h'))e'))r'))o'))u'))s')) '))o'))f')) '))b'))e')) [A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ca')))[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cc'))[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ch'[C) '))[Ca'))n'))d')) '))r'))e'))a'))c'))h'))[C[C[C
<_sre.SRE_Match object; span=(7, 12), match='peach'>
>>> 
>>> 
>>> 
>>> 
>>> xx[K[Kexit()
]0;azeez@azeez-Inspiron-15-3567: ~/Documents[01;32mazeez@azeez-Inspiron-15-3567[00m:[01;34m~/Documents[00m$ exit
exit

Script done on 2020-05-29 14:36:49+0100
